<!-- Begin setup -->

import Layout from "./components/layout";
import BabelRepl from "./components/babel-repl";
import LiveEditor from "./components/live-editor";
import SoloEditor from "./components/solo-editor";
import { Logo } from "./components/shared";
import reactUsage from "./assets/react-usage.png";


import baseTheme from "./theme";

export const theme = baseTheme;


<Head>
  <title>Slides | Intro to React</title>
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="https://instructure-uploads.s3.amazonaws.com/account_158020000000000001/attachments/43718/flatiron-favicon.ico"
  />
</Head>

<!-- End setup -->

<!-- Begin Slide -->

<Layout>

# Intro to React

<Logo />

</Layout>

<!-- End Slide -->

---

# Questions?

<iframe width="1000" height="800" src="https://docs.google.com/document/d/1iAtutIgh8L-WSi6TaURiAmq_S5yglduQCNx3x9qI29o/edit#"></iframe>

<Notes>

If you have any questions throughout lecture and you want to make sure they don't get lost in the chat, feel free to add them to this google doc and let me know! We'll come back and take a look at it together and fill in some answers and notes.

</Notes>

---

<!-- Begin Slide -->

<Layout>

# ‚úÖ Objectives

We'll learn...

<Steps>

- Why you should learn React
- React's philosophy
- How React works

</Steps>

</Layout>

<Notes>

Our goal today will be to talk about ‚¨áÔ∏è 

- Why you should learn react ‚¨áÔ∏è 

- A bit about React's philosophy ‚¨áÔ∏è 

- and a high level discussion of how React works

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# ü§î Why React?

<img src={reactUsage} alt="component diagram" style={{ height: "600px" }} />

_&mdash; [Frontend Framework Usage, 2020 State of JS Survey](https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/)_

</Layout>

<Notes>

- One key reason we teach React is simply its popularity in the marketplace
- But React is also popular for a reason
- It solved a lot of problems developers had in the past with other frontend libraries
- It also has some good tricks up its sleeve to solve these problems in a way that doesn't sacrifice performance

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# ü§î Why React?

Writing vanilla JavaScript is hard!
Particularly when it comes to:

- Creating/Updating DOM elements
- Code organization (separation of concerns)

</Layout>

<Notes>

Beyond its popularity... let's talk about some more reasons react is a good tool to use.

Some of the main challenges in building vanilla JS projects have to do with keeping the DOM up to date and keeping organized as the codebase grows.

- If you struggled with those things while you were working on your project, you're not alone! These are hard problems, and something JS developers have struggled with for a long time
- React gives us code to solve these problems by _abstracting_ the work of manipulating the DOM
- It also has strong opinions about how your code should be organized
  - If you "buy into" React's philosophy, you're gonna have a good time with React...
  - If you fight against it, you'll struggle

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# üí° React Philosophy

- Use **declarative syntax (JSX)**
  - Makes it easier to work with the DOM
  - Clearer connection between the code we write and what is displayed in the browser
- Use **components** to break down complex UI into smaller pieces
  - Separation of concerns
  - Easier to maintain

</Layout>

<Notes>

One of the key elements of React's philosophy is the use of declarative syntax.

React introduced the syntax called JSX (short for javascript XML) that
- makes it easier to work with the DOM
- establishes a clearer connection between the code we write and what is actually displayed in the browser

Another key idea in React's philosophy is to use Components to break down a complex UI into smaller and more manageable pieces.

This also helps us with separation of conerns and makes our codebase easier to maintain and organize as it grows.

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# üéâ Declarative Syntax

<img src="https://res.cloudinary.com/dnocv6uwb/image/upload/v1645224107/DzpaGi_ov-gH8BoHDNzkLYwPTOeKsl60Pj_3nsCSY8I_fmi8fq.jpg" alt="Declarative vs Imperative code comic" style={{height: '400px', marginBottom: '40px'}}/>

<iframe height="360" width="1000" src="https://docs.google.com/document/d/1nPeQ0bahVgfDKag2QB9ztRsIRs0NDAqJ9tCkeBt2iI8/edit"></iframe>

</Layout>

<Notes>

When we see the word Declarative, what does that mean? When we think of the difference between declarative and imperative code, who can describe to me or give me an example of that difference? 

- (wait for and explore examples)
- Chipotle analogy: ordering a burrito vs making one by hand (outsourcing in general)

Declarative code lets us write something more _abstract_.

- We don't have to worry about the low-level details of what's happening under the hood
- We can focus more on the end result (in this case, what's being rendered to the DOM)

</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

# üéâ Declarative Syntax



<Steps>

Instead of describing _how to do something_...

<div>
<SoloEditor>

```js
const h1 = document.createElement("h1");
h1.id = "main";
h1.className = "blue";
h1.textContent = "Hello!";
```

</SoloEditor>
</div>

...just describe _what we want_:

<div>
<SoloEditor>

```js
const h1 = (
  <h1 id="main" className="blue">
    Hello from JSX!
  </h1>
);
```

</SoloEditor>
</div>

</Steps>

</Layout>

<Notes>

(This slide has code examples that can be revealed with down arrows.)

</Notes>

<!-- End Slide -->

---

<Layout>

# ü§î But How?

Under the hood, React apps use a tool called Babel to **transpile** the JSX syntax to valid JavaScript:

<Steps>

- We write JSX
- Babel **transpiles** JSX into valid JavaScript
- That **transpiled** code is what actually runs in the browser

</Steps>

</Layout>

<Notes>

Under the hood, React apps use a tool called Babel to **transpile** the JSX syntax to valid JavaScript:

(Use arrows to reveal...)
- We write JSX
- Babel **transpiles** JSX into valid JavaScript
- That **transpiled** code is what actually runs in the browser

Just a quick **Note**: JSX and Babel are tools that exist within the javascript ecosystem, both are usable outside of React as well.

For an example of how this works -> Next Slide
</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

## JSX ‚û°Ô∏è Babel ‚û°Ô∏è JS

<BabelRepl>

```js
const h1 = (
  <h1 id="main" className="blue">
    Hello from JSX!
  </h1>
);
```

</BabelRepl>

</Layout>

<Notes>

In this window, the left-hand side is JSX (JavaScript XML). It looks like HTML, but it's not!
This is a special kind of markup that we use to tell React how we want the DOM to look.

We write JSX in our JavaScript files, and under the hood, Babel turns it into valid JavaScript
code before the browser runs it. If we tried running the code on the left in the browser we'd get a syntax error.
But after Babel is done with it, it's now valid syntax.

You don't have to worry too much about this; you can just use JSX in React without thinking about it.
But it's good to know what's happening. At the end of the day, it's all still JavaScript.

Again, the details of this are not important to remember, but you do want to remember that JSX requires transpilation via babel in order to run in the browser. If you're using the create-react-app generator, then all of this is already configured for you up front, including a live updating development server!

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# üõ† Components

Components are the building blocks of React. A **component** is a function that:

- Takes in some **raw data (props)**
- Returns **user interface (JSX)**

<SoloEditor>

```js
function Header(props) {
  return (
    <div>
      <h3>{props.title}</h3>
      <h4>Subtitle: {props.subtitle}</h4>
    </div>
  );
}
```

</SoloEditor>

</Layout>

<Notes>

Components are the building blocks of React!

Simply put, a component is a function that:

- takes in some raw data (in the form of an object that we call props)
- and returns some JSX (to render part of our user interface)

You can see here that we have a function called `Header` that takes an argument called props and returns a JSX element, in this case a div, including the title and subtitle properties from the `props` argument. So let's take a closer look at this.


</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

<LiveEditor>

```js
function Header(props) {
  return (
    <div>
      <h3>{props.title}</h3>
      <h4>Subtitle: {props.subtitle}</h4>
    </div>
  );
}

// <Header title="Let's Learn React" subtitle="Components as JSX" />
// is equivalent to
// Header({title: "Let's Learn React", subtitle: "Components as function calls"})

ReactDOM.render(
  <Header title="Let's Learn React" subtitle="Components" />,
  document.getElementById("root")
);
```

</LiveEditor>

</Layout>

<Notes>

Here's an example of a live editor within the slideshow (all possible because of React!) On the left is the code we write.
On the right is a preview of the rendered HTML on top and the HTML code that the browser actually renders on the bottom.

Think of a component like a **template** for how we want to display some data.

As React developers, our job is to take some raw data (a string, an object, an array, etc) and decide
how a user should interact with that data (how it should be displayed on the page).

Components are what make that possible!

The syntax might take some getting used to, but remember, in the end it's all just JavaScript.
Think of writing `<Header props="something">` like us telling React to call the function `Header`,
and pass one argument of an object with key-value pairs. (we could even write it out this way and it'd still work)

Let's try adding a prop for Category here.

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# üë∑‚Äç‚ôÄÔ∏è Component Composition

<img
  src="https://curriculum-content.s3.amazonaws.com/react/yelp-components.png"
  alt="component diagram"
  style={{ height: "600px" }}
/>

</Layout>

<Notes>

Now, let's take a moment to talk about Component Composition

The last example we saw was a simple React component, but a typical React app can have dozens or even hundreds of components.
The great thing about components is that we can **compose** them (make them work together) to put together complex layouts.
(Even this slideshow is just a bunch of React components!)

The image here is part of Yelp's website, and an example of some of the components they might use to put together an app like this.
Take note of how components let us:

- separate different areas of concern (navigation vs map view vs list view)
- create reusable templates (we can re-use the same code from the ResultItem component to display multiple results)

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

<LiveEditor>

```js
/* Component 1 */
function Article(props) {
  return (
    <div>
      <h3>{props.title}</h3>
      <h4>Subtitle: {props.subtitle}</h4>
      <hr />
      <Comment content="First!" />
      <Comment content="What a great article." />
    </div>
  );
}

/* Component 2 */
function Comment(props) {
  return <p>{props.content}</p>;
}

/* Render the whole application */
ReactDOM.render(
  <Article title="Let's Learn React" subtitle="Components" />,
  document.getElementById("root")
);
```

</LiveEditor>

</Layout>

<Notes>

Here's an example of what the code looks like for composing multiple components together.
An article can have many comments, so we're using the Comment component within the Article component.

Each component is responsible for its own template, but its "parent" (whichever component returns it)
is responsible for providing its data.

We're _reusing_ the Comment component to make a couple of `<p>` tags, each with their own content.

Within ReactDOM.render(), we're rendering the Article component which in turn renders the appropriate comments. When we speak of this parent child relationship, we'll be using that metaphor much like we did for DOM nodes within JS. So, the parent component is the one that renders its children. A child component is rendered by its parent.

In this case, when we use the term render, we mean that the component renders the JSX we're referring to. Remember that all of our components are javascript functions, so when one component returns JSX including another component, that rendering component is the parent component and the component included in that parent is called the child component.

I want to pause for a moment and ask y'all if there's anything you'd like to try here or ask about or discuss more.

</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

# Understanding ReactDOM.render()

<Steps>

- What does `ReactDOM.render()` do?

- --> inserts a react element into the DOM 

- How do the arguments we pass to `ReactDOM.render()` accomplish this?

- --> the first argument is the react element we'd like to render to the DOM (JSX)
- --> the second argument is the DOM node where we want to insert that react element

</Steps>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# üöó React Roadmap

<Steps>

- Create a static frontend site with **components** and **props** (DOM Manipulation)
- Use **state** and **events** to make your site dynamic (Event Handling)
- Add **side effects** and **data fetching** to communicate with a server (Network Communication)

</Steps>

</Layout>

<Notes>

Your objective during week 1 of React is to learn the fundamentals of React to make a single-page application.
We'll be building something similar to what you made in Phase 1, but with a new set of tools to make that process easier.

Learning this will be challenging because you'll need to learn new syntax, as well as learning a new philosophy for how to organize your code.
And, since at the end of the day, React is still JavaScript, you'll need your sharpest JS skills to become great React developers.

Eventually, we'll again be stitching together those three pillars of javascript within our react application to:  (use arrow keys to expand)

Right now, the most important thing is to start writing code, so in the next part of the lecture we'll get into a little exercise
to practice with components, JSX and props.

</Notes>

<!-- End Slide -->

---

# The ToyTale Exercise

<iframe src="https://codesandbox.io/embed/adoring-clarke-138zs?view=preview"
    style={{width:'70%', height:'800px', border:0, borderRadius: '4px',overflow:'hidden'}}
    title="adoring-clarke-138zs"
    allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
    sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
  ></iframe>

<Notes>

So, our exercise today is going to be to rework the HTML and JS for the Toy Tale practice code challenge so that it works within React.

Here's a little preview of what we'll be working towards for the day. When our work is complete, we'll have something like this running within our dev server. So, we'll be able to see all of the toys displayed on the page. The form to add a new toy isn't going to work today, but that's okay, it's not the focus for today!

The starter code in the repository is based on the html from the code challenge and still has some html in it that isn't JSX friendly. So, part of your task for the day will be to use your knowledge of how JSX differs from HTML to refactor the HTML to be valid JSX. 

</Notes>

---

# Exercise Instructions

- Fork and Clone the cohort repo
  - Navigate to 01_intro_to_react/toy_tale_react and run `npm start`
- Activity #1: Convert HTML to JSX within src/App.js
    - What needs to change? What's the same? 
    - After fixing any errors in the console, use comments to begin to map out JSX elements into into separate components. No need to actually create components now, just start thinking about what pieces of JSX could be split into their own components.
- Take 5-7 minutes for this on your own and then we'll go through it together mob-programming style


---

# Exercise Instructions

- Activity #2: Implement a ToyCard Component
    - Start by hard-coding the JSX in your App component return statement
    - Use props to make your component reusable
    - Copy/paste data from the "toys.js" file as props and iterate over Toy objects
      to create a ToyCard component for each one
    - BONUS: 
      - Import and store data from the "toys.js" file
      - Create a "components" subdirectory + "ToyCard.js" file
- Take 10 minutes for this on your own, feel free to ask questions as you go and then we'll review together.

---

# Recap of Key Skills

- Use ReactDOM.render() to add JSX elements to the DOM
- Use Components as a way of separating UI concerns splitting UI into smaller reusable pieces
- Use JSX to render HTML elements &amp; other React components

---

<!-- Begin Slide -->

<Layout>

# ü§î Questions?

<iframe width="1000" height="800" src="https://docs.google.com/document/d/1iAtutIgh8L-WSi6TaURiAmq_S5yglduQCNx3x9qI29o/edit#"></iframe>

</Layout>

<!-- End Slide -->

---

# Installing and Using the React Developer Tools

<iframe width="800" height="450" src="https://www.youtube.com/embed/fXRB6wgeKOo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

<!-- Begin Slide -->

<Layout>

# üë∑‚Äç‚ôÄÔ∏è Resources

- [React with Hooks Docs](https://reactwithhooks.netlify.app/)
- [Babel Playground](https://babeljs.io/repl)
- [Create React App](http://create-react-app.dev/)
- [Dan Abramov's Blog](https://overreacted.io/)

</Layout>

<!-- End Slide -->
